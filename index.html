<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Sensores ACS</title>

  <!-- Chart.js (v4) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <!-- Adaptador de fechas (NECESARIO para eje time) -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  <!-- Zoom/Pan compatible con Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>

  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 20px; background:#fafafa; }
    #container { max-width: 1200px; }
    h1 { margin: 0 0 6px; }
    .info { color:#555; font-size: 14px; margin-bottom: 14px; }
    button { padding: 6px 12px; cursor: pointer; }
    #status { margin-left: 10px; font-size: 12px; color:#666; }
    .error { margin-top: 12px; color: #b00020; white-space: pre-wrap; }
    /* IMPORTANTE: si el canvas no tiene altura, a veces se ve “vacío” */
    #chartACS { width: 100%; height: 70vh; }
  </style>
</head>

<body>
  <div id="container">
    <h1>Sensores ACS</h1>
    <div class="info">
      Histórico automático cada 15 minutos · Zoom con rueda · Pan arrastrando · Click en leyenda para ocultar/mostrar series
    </div>

    <div style="margin-bottom:10px;">
      <button id="btnReset">Reset zoom</button>
      <span id="status"></span>
    </div>

    <canvas id="chartACS"></canvas>
    <div id="err" class="error"></div>
  </div>

  <script>
    let chart;

    function showError(msg) {
      document.getElementById("err").textContent = msg || "";
    }

    async function fetchJson(url) {
      const res = await fetch(url + "?t=" + Date.now());
      if (!res.ok) throw new Error("No se puede leer " + url + " (HTTP " + res.status + ")");
      return await res.json();
    }

    async function fetchText(url) {
      const res = await fetch(url + "?t=" + Date.now());
      if (!res.ok) throw new Error("No se puede leer " + url + " (HTTP " + res.status + ")");
      return await res.text();
    }

    function parseTxtToPoints(text) {
      const points = [];
      const lines = text.split("\n").map(l => l.trim()).filter(Boolean);

      for (const line of lines) {
        const parts = line.split(";");
        if (parts.length < 2) continue;

        const ts = parts[0].trim();
        let val = parts[1].trim();

        if (val === "NOT_FOUND") continue;

        // por si alguna vez viene con coma decimal
        val = val.replace(",", ".");

        const y = Number(val);
        if (Number.isNaN(y)) continue;

        const x = new Date(ts);
        if (isNaN(x.getTime())) continue;

        points.push({ x, y });
      }
      return points;
    }

    function buildChart(datasets) {
      const ctx = document.getElementById("chartACS").getContext("2d");

      chart = new Chart(ctx, {
        type: "line",
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          interaction: { mode: "nearest", intersect: false },
          scales: {
            x: {
              type: "time",
              title: { display: true, text: "Fecha y hora" }
            },
            y: {
              title: { display: true, text: "Valor" }
            }
          },
          plugins: {
            zoom: {
              pan: { enabled: true, mode: "x" },
              zoom: {
                wheel: { enabled: true },
                pinch: { enabled: true },
                mode: "x"
              }
            },
            tooltip: { enabled: true }
          }
        }
      });
    }

    async function loadAllAcsSeries() {
      showError("");

      const status = document.getElementById("status");
      status.textContent = "Cargando…";

      const manifest = await fetchJson("data/acs_manifest.json");
      status.textContent = "Última actualización (UTC): " + (manifest.timestamp_utc || "-");

      const datasets = [];

      for (const s of (manifest.acs || [])) {
        const txt = await fetchText("data/" + s.file);
        const points = parseTxtToPoints(txt);

        if (!points.length) continue;

        datasets.push({
          label: `${s.item} – ${s.label} (${s.units || ""})`,
          data: points,
          tension: 0.2,
          pointRadius: 2,
          borderWidth: 2
        });
      }

      if (!datasets.length) {
        showError("No hay datos numéricos todavía en los TXT (solo NOT_FOUND o vacío). Espera 1–2 ejecuciones del workflow.");
      }

      if (!chart) buildChart(datasets);
      else {
        chart.data.datasets = datasets;
        chart.update();
      }
    }

    document.getElementById("btnReset").addEventListener("click", () => {
      if (chart) chart.resetZoom();
    });

    // Carga inicial y refresco
    loadAllAcsSeries().catch(e => showError(String(e)));
    setInterval(() => {
      loadAllAcsSeries().catch(e => showError(String(e)));
    }, 30000);
  </script>
</body>
</html>
