<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visor S (Temperaturas) + D (Bombas / Equipos)</title>

  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --line:#ddd; --chip:#f3f4f6; --warn:#b00020; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; color: var(--fg); background: var(--bg); }
    h1 { margin: 0 0 6px 0; font-size: 22px; }
    .sub { color: var(--muted); margin-bottom: 14px; font-size: 13px; }
    .bar {
      display:flex; gap:10px; align-items:center; flex-wrap: wrap;
      border:1px solid var(--line); padding:10px; border-radius:10px;
    }
    .bar label { font-size: 13px; color: var(--fg); }
    select, button {
      font-size: 13px; padding:6px 10px; border:1px solid var(--line); border-radius: 8px; background: #fff;
      cursor: pointer;
    }
    button:hover { background: #fafafa; }
    .chip {
      display:inline-block; padding:4px 8px; border-radius: 999px; background: var(--chip);
      font-size: 12px; color: var(--muted);
    }

    .grid {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .panel {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      min-height: 120px;
    }
    .panel h2 { font-size: 14px; margin: 0 0 8px 0; }
    .list {
      max-height: 240px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px;
    }
    .row {
      display:flex; gap:8px; align-items:center;
      padding: 4px 2px;
      border-bottom: 1px dashed #eee;
      font-size: 13px;
    }
    .row:last-child { border-bottom: none; }
    .row code { background:#f7f7f7; padding:2px 6px; border-radius:6px; font-size: 12px; }
    .actions { display:flex; gap:8px; justify-content:flex-end; margin: 8px 0 0 0; }

    .plots {
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .plotbox {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px;
    }
    #plotS { height: 460px; }
    #plotD { height: 320px; }

    .note { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .err {
      display:none;
      margin-top: 12px;
      border: 1px solid #f2b8b5;
      background: #fff5f5;
      border-radius: 10px;
      padding: 10px;
      color: var(--warn);
      white-space: pre-wrap;
      font-size: 12px;
    }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      #plotS { height: 420px; }
      #plotD { height: 300px; }
    }
  </style>
</head>

<body>
  <h1>Visor S (Temperaturas) + D (Bombas / Equipos)</h1>
  <div class="sub">
    Ahora hay 2 gráficas: una para S (°C) y otra para D (0/1). Zoom con rueda y pan arrastrando.
    <br>
    <b>Importante:</b> si abres este archivo desde <code>github.com/.../blob/...</code>, GitHub no ejecuta scripts. Ábrelo desde GitHub Pages.
  </div>

  <div class="bar">
    <label>Rango:</label>
    <select id="rangeSel">
      <option value="24h">Últimas 24h</option>
      <option value="7d">Últimos 7 días</option>
      <option value="30d">Últimos 30 días</option>
      <option value="all">Todo</option>
    </select>
    <button id="btnReload">Recargar</button>
    <button id="btnResetZoomS">Reset zoom S</button>
    <button id="btnResetZoomD">Reset zoom D</button>
    <span id="status" class="chip">Cargando…</span>
  </div>

  <div class="grid">
    <div class="panel">
      <h2>Temperaturas (S)</h2>
      <div class="actions">
        <button id="sAll">Mostrar todas</button>
        <button id="sNone">Ocultar todas</button>
      </div>
      <div id="sList" class="list"></div>
    </div>

    <div class="panel">
      <h2>Bombas / Equipos (D)</h2>
      <div class="actions">
        <button id="dAll">Mostrar todas</button>
        <button id="dNone">Ocultar todas</button>
      </div>
      <div id="dList" class="list"></div>
      <div class="note">Nota: los drivers se muestran como 0/1 (OFF/ON).</div>
    </div>
  </div>

  <div class="plots">
    <div class="plotbox">
      <div class="note"><b>Gráfica S</b> (Temperaturas superpuestas)</div>
      <div id="plotS"></div>
    </div>
    <div class="plotbox">
      <div class="note"><b>Gráfica D</b> (Drivers 0/1)</div>
      <div id="plotD"></div>
    </div>
  </div>

  <div id="err" class="err"></div>

<script>
/**
 * Estructura esperada:
 *  - data/latest_all.json
 *  - data/S1.txt, data/S2.txt, ...
 *  - data/d_D1.txt, data/d_D2.txt, ...
 */

const DATA_DIR = "data";
const $ = (id) => document.getElementById(id);

function showError(msg) {
  const box = $("err");
  box.style.display = "block";
  box.textContent = msg;
}

function clearError() {
  const box = $("err");
  box.style.display = "none";
  box.textContent = "";
}

// ---- Plotly loader con fallback (para Chrome/filters/CDN)
async function loadPlotly() {
  if (window.Plotly) return true;

  const cdns = [
    "https://cdn.plot.ly/plotly-2.30.0.min.js",
    "https://unpkg.com/plotly.js-dist-min@2.30.0/plotly.min.js",
    "https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.30.0/plotly.min.js"
  ];

  for (const src of cdns) {
    try {
      await new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
      if (window.Plotly) return true;
    } catch (e) {
      // prueba siguiente CDN
    }
  }
  return false;
}

const state = {
  meta: null,
  sensors: [],
  drivers: [],
  selectedS: new Set(),
  selectedD: new Set(),
  cache: new Map(), // item -> [{t:Date, v:number}]
  lastUpdated: null
};

function setStatus(txt) {
  $("status").textContent = txt;
}

function normalizeOnOffTo01(x) {
  const v = String(x ?? "").trim().toLowerCase();
  if (v === "on" || v === "true" || v === "yes" || v === "1") return 1;
  if (v === "off" || v === "false" || v === "no" || v === "0") return 0;
  const n = Number(v);
  if (!Number.isNaN(n)) return n;
  return null;
}

function parseHistoryText(text, isDriver=false) {
  const out = [];
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  for (const line of lines) {
    let parts = line.split(",");
    if (parts.length < 2) parts = line.split(";");
    if (parts.length < 2) parts = line.split(/\s+/);
    if (parts.length < 2) continue;

    const ts = parts[0].trim();
    const raw = parts.slice(1).join(" ").trim();

    const t = new Date(ts);
    if (Number.isNaN(t.getTime())) continue;

    let v;
    if (isDriver) {
      v = normalizeOnOffTo01(raw);
      if (v === null) continue;
    } else {
      v = Number(String(raw).replace(",", "."));
      if (Number.isNaN(v)) continue;
    }
    out.push({ t, v });
  }

  out.sort((a,b) => a.t - b.t);
  return out;
}

async function fetchText(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  return await res.text();
}

async function fetchJSON(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  return await res.json();
}

function rangeToMs(r) {
  if (r === "24h") return 24 * 60 * 60 * 1000;
  if (r === "7d")  return 7  * 24 * 60 * 60 * 1000;
  if (r === "30d") return 30 * 24 * 60 * 60 * 1000;
  return null; // all
}

function filterByRange(series, rangeKey) {
  const ms = rangeToMs(rangeKey);
  if (!ms) return series;
  const last = series.length ? series[series.length - 1].t.getTime() : Date.now();
  const minT = last - ms;
  return series.filter(p => p.t.getTime() >= minT);
}

function buildCheckboxRow(container, item, label, checked, onChange) {
  const row = document.createElement("div");
  row.className = "row";

  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = checked;
  cb.addEventListener("change", () => onChange(cb.checked));

  const code = document.createElement("code");
  code.textContent = item;

  const span = document.createElement("span");
  span.textContent = label || "";

  row.appendChild(cb);
  row.appendChild(code);
  row.appendChild(span);
  container.appendChild(row);
}

function renderLists() {
  const sList = $("sList");
  const dList = $("dList");
  sList.innerHTML = "";
  dList.innerHTML = "";

  for (const s of state.sensors) {
    buildCheckboxRow(
      sList,
      s.item,
      `${s.label || ""}${s.units ? " ("+s.units+")" : ""}`,
      state.selectedS.has(s.item),
      (ok) => {
        if (ok) state.selectedS.add(s.item);
        else state.selectedS.delete(s.item);
        redrawAll();
      }
    );
  }

  for (const d of state.drivers) {
    buildCheckboxRow(
      dList,
      d.item,
      d.label || "",
      state.selectedD.has(d.item),
      (ok) => {
        if (ok) state.selectedD.add(d.item);
        else state.selectedD.delete(d.item);
        redrawAll();
      }
    );
  }
}

function fileForItem(item) {
  if (/^S\d+$/.test(item)) return `${DATA_DIR}/${item}.txt`;
  if (/^D\d+$/.test(item)) return `${DATA_DIR}/d_${item}.txt`;
  return null;
}

async function loadSeries(item) {
  if (state.cache.has(item)) return state.cache.get(item);
  const url = fileForItem(item);
  if (!url) return [];

  const isDriver = /^D\d+$/.test(item);
  const txt = await fetchText(url);
  const series = parseHistoryText(txt, isDriver);
  state.cache.set(item, series);
  return series;
}

function labelFor(item) {
  const s = state.sensors.find(x => x.item === item);
  if (s) return `${s.item} · ${s.label || ""}`.trim();
  const d = state.drivers.find(x => x.item === item);
  if (d) return `${d.item} · ${d.label || ""}`.trim();
  return item;
}

function emptyLayoutCommon(title) {
  return {
    margin: { l: 60, r: 30, t: 30, b: 50 },
    title: { text: title, font: { size: 14 } },
    xaxis: { title: "Fecha y hora", showgrid: true, zeroline: false },
    hovermode: "x unified"
  };
}

async function redrawS(rangeKey) {
  const sel = Array.from(state.selectedS);
  const seriesArr = await Promise.all(sel.map(it => loadSeries(it).catch(() => [])));

  const traces = [];
  for (let i = 0; i < sel.length; i++) {
    const item = sel[i];
    const raw = seriesArr[i] || [];
    const serie = filterByRange(raw, rangeKey);

    traces.push({
      type: "scatter",
      mode: "lines",
      name: labelFor(item),
      x: serie.map(p => p.t),
      y: serie.map(p => p.v),
      hovertemplate: "%{x}<br>%{y:.2f}°C<extra></extra>",
    });
  }

  const layout = {
    ...emptyLayoutCommon("Temperaturas (S)"),
    yaxis: { title: "Temperatura (°C)", showgrid: true, zeroline: false, automargin: true }
  };

  const config = { responsive: true, scrollZoom: true, displaylogo: false };

  if (!traces.length) {
    await Plotly.newPlot("plotS", [{type:"scatter", mode:"lines", x:[], y:[]}], layout, config);
    return { lastTs: null };
  }

  await Plotly.newPlot("plotS", traces, layout, config);

  let lastTs = null;
  for (const it of sel) {
    const s = state.cache.get(it);
    if (s && s.length) lastTs = Math.max(lastTs || 0, s[s.length - 1].t.getTime());
  }
  return { lastTs };
}

async function redrawD(rangeKey) {
  const sel = Array.from(state.selectedD);
  const seriesArr = await Promise.all(sel.map(it => loadSeries(it).catch(() => [])));

  const traces = [];
  for (let i = 0; i < sel.length; i++) {
    const item = sel[i];
    const raw = seriesArr[i] || [];
    const serie = filterByRange(raw, rangeKey);

    traces.push({
      type: "scatter",
      mode: "lines",
      name: labelFor(item) + " (0/1)",
      x: serie.map(p => p.t),
      y: serie.map(p => p.v),
      line: { shape: "hv" },
      hovertemplate: "%{x}<br>%{y}<extra></extra>",
    });
  }

  const layout = {
    ...emptyLayoutCommon("Drivers (D)"),
    yaxis: { title: "Estado (0/1)", range: [-0.1, 1.1], showgrid: true, zeroline: false, automargin: true }
  };

  const config = { responsive: true, scrollZoom: true, displaylogo: false };

  if (!traces.length) {
    await Plotly.newPlot("plotD", [{type:"scatter", mode:"lines", x:[], y:[]}], layout, config);
    return { lastTs: null };
  }

  await Plotly.newPlot("plotD", traces, layout, config);

  let lastTs = null;
  for (const it of sel) {
    const s = state.cache.get(it);
    if (s && s.length) lastTs = Math.max(lastTs || 0, s[s.length - 1].t.getTime());
  }
  return { lastTs };
}

async function redrawAll() {
  clearError();
  const okPlotly = await loadPlotly();
  if (!okPlotly) {
    setStatus("Error: Plotly no carga.");
    showError(
      "No se pudo cargar Plotly (CDN bloqueado o sin conexión).\n" +
      "Prueba sin bloqueadores / en otra red.\n"
    );
    return;
  }

  const rangeKey = $("rangeSel").value;
  const selS = state.selectedS.size;
  const selD = state.selectedD.size;

  setStatus(`Cargando… (${selS} S + ${selD} D)`);

  try {
    const a = await redrawS(rangeKey);
    const b = await redrawD(rangeKey);

    const last = Math.max(a.lastTs || 0, b.lastTs || 0);
    state.lastUpdated = last ? new Date(last) : null;

    const stamp = state.lastUpdated ? state.lastUpdated.toISOString() : "—";
    setStatus(`Mostrando: ${selS} S + ${selD} D · ${stamp}`);
  } catch (e) {
    console.error(e);
    setStatus("Error al dibujar (mira detalle).");
    showError(String(e?.stack || e?.message || e));
  }
}

function resetZoomS() {
  if (!window.Plotly) return;
  Plotly.relayout("plotS", { "xaxis.autorange": true, "yaxis.autorange": true });
}
function resetZoomD() {
  if (!window.Plotly) return;
  Plotly.relayout("plotD", { "xaxis.autorange": true, "yaxis.autorange": false });
}

async function init() {
  clearError();

  const okPlotly = await loadPlotly();
  if (!okPlotly) {
    setStatus("Error: Plotly no carga.");
    showError(
      "No se pudo cargar Plotly.\n" +
      "Si estás abriendo desde github.com/blob, no va a funcionar.\n" +
      "Ábrelo desde GitHub Pages (https://TUUSUARIO.github.io/TUREPO/visor.html).\n"
    );
    return;
  }

  try {
    setStatus("Cargando latest_all.json…");
    const meta = await fetchJSON(`${DATA_DIR}/latest_all.json`);
    state.meta = meta;

    state.sensors = (meta.sensors || [])
      .filter(x => /^S\d+$/.test(String(x.item||"").trim()))
      .map(x => ({ item: String(x.item).trim(), label: x.label || "", units: x.units || "" }))
      .sort((a,b) => Number(a.item.slice(1)) - Number(b.item.slice(1)));

    state.drivers = (meta.drivers || [])
      .filter(x => /^D\d+$/.test(String(x.item||"").trim()))
      .map(x => ({ item: String(x.item).trim(), label: x.label || "", units: x.units || "" }))
      .sort((a,b) => Number(a.item.slice(1)) - Number(b.item.slice(1)));

    // selección inicial vacía (si quieres defaults, añade aquí)
    state.selectedS = new Set();
    state.selectedD = new Set();

    renderLists();

    // dibuja vacío
    await redrawAll();

  } catch (e) {
    console.error(e);
    setStatus("Error cargando datos (mira detalle).");
    showError(String(e?.stack || e?.message || e));
  }
}

// botones
$("btnReload").addEventListener("click", async () => {
  state.cache.clear();
  await init();
});

$("btnResetZoomS").addEventListener("click", resetZoomS);
$("btnResetZoomD").addEventListener("click", resetZoomD);

$("rangeSel").addEventListener("change", () => redrawAll());

$("sAll").addEventListener("click", () => {
  state.sensors.forEach(s => state.selectedS.add(s.item));
  renderLists();
  redrawAll();
});
$("sNone").addEventListener("click", () => {
  state.selectedS.clear();
  renderLists();
  redrawAll();
});
$("dAll").addEventListener("click", () => {
  state.drivers.forEach(d => state.selectedD.add(d.item));
  renderLists();
  redrawAll();
});
$("dNone").addEventListener("click", () => {
  state.selectedD.clear();
  renderLists();
  redrawAll();
});

init();
</script>
</body>
</html>
