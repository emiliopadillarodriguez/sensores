<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visor S (Temperaturas) + D (Bombas / Equipos)</title>

  <!-- Plotly (muy robusto para series múltiples y 2 ejes) -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --line:#ddd; --chip:#f3f4f6; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; color: var(--fg); background: var(--bg); }
    h1 { margin: 0 0 6px 0; font-size: 22px; }
    .sub { color: var(--muted); margin-bottom: 14px; font-size: 13px; }
    .bar {
      display:flex; gap:10px; align-items:center; flex-wrap: wrap;
      border:1px solid var(--line); padding:10px; border-radius:10px;
    }
    .bar label { font-size: 13px; color: var(--fg); }
    select, button {
      font-size: 13px; padding:6px 10px; border:1px solid var(--line); border-radius: 8px; background: #fff;
      cursor: pointer;
    }
    button:hover { background: #fafafa; }
    .chip {
      display:inline-block; padding:4px 8px; border-radius: 999px; background: var(--chip);
      font-size: 12px; color: var(--muted);
    }

    .grid {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .panel {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      min-height: 120px;
    }
    .panel h2 { font-size: 14px; margin: 0 0 8px 0; }
    .list {
      max-height: 240px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px;
    }
    .row {
      display:flex; gap:8px; align-items:center;
      padding: 4px 2px;
      border-bottom: 1px dashed #eee;
      font-size: 13px;
    }
    .row:last-child { border-bottom: none; }
    .row code { background:#f7f7f7; padding:2px 6px; border-radius:6px; font-size: 12px; }
    .actions { display:flex; gap:8px; justify-content:flex-end; margin: 8px 0 0 0; }
    #plot {
      margin-top: 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px;
      height: 520px;
    }
    .note { font-size: 12px; color: var(--muted); margin-top: 6px; }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      #plot { height: 460px; }
    }
  </style>
</head>

<body>
  <h1>Visor S (Temperaturas) + D (Bombas / Equipos)</h1>
  <div class="sub">
    Elige qué series quieres ver. S va en °C (eje izquierdo) y D en 0/1 (eje derecho). Zoom con rueda y pan arrastrando.
  </div>

  <div class="bar">
    <label>Rango:</label>
    <select id="rangeSel">
      <option value="24h">Últimas 24h</option>
      <option value="7d">Últimos 7 días</option>
      <option value="30d">Últimos 30 días</option>
      <option value="all">Todo</option>
    </select>
    <button id="btnReload">Recargar</button>
    <button id="btnResetZoom">Reset zoom</button>
    <span id="status" class="chip">Cargando…</span>
  </div>

  <div class="grid">
    <div class="panel">
      <h2>Temperaturas (S)</h2>
      <div class="actions">
        <button id="sAll">Mostrar todas</button>
        <button id="sNone">Ocultar todas</button>
      </div>
      <div id="sList" class="list"></div>
    </div>

    <div class="panel">
      <h2>Bombas / Equipos (D)</h2>
      <div class="actions">
        <button id="dAll">Mostrar todas</button>
        <button id="dNone">Ocultar todas</button>
      </div>
      <div id="dList" class="list"></div>
      <div class="note">Nota: los drivers se muestran como 0/1 (OFF/ON).</div>
    </div>
  </div>

  <div id="plot"></div>

<script>
/**
 * Estructura esperada de ficheros:
 *  - data/latest_all.json
 *  - data/S1.txt, data/S2.txt, ...
 *  - data/d_D1.txt, data/d_D2.txt, ...
 *
 * Formato de .txt: el parser es tolerante.
 * Soporta líneas tipo:
 *   2026-01-11T10:00:00Z,62.3
 *   2026-01-11T10:00:00Z;62.3
 *   2026-01-11T10:00:00Z 62.3
 * y también On/Off/True/False/1/0 en drivers.
 */

const DATA_DIR = "data";

const $ = (id) => document.getElementById(id);

const state = {
  meta: null,
  sensors: [],   // [{item:"S1", label:"...", units:"..."}]
  drivers: [],   // [{item:"D1", label:"...", units:"..."}]
  selectedS: new Set(),
  selectedD: new Set(),
  cache: new Map(), // key -> parsed series [{t:Date, v:number}]
  lastRange: "24h",
  lastUpdated: null,
};

function setStatus(txt) {
  $("status").textContent = txt;
}

function normalizeOnOffTo01(x) {
  const v = String(x ?? "").trim().toLowerCase();
  if (v === "on" || v === "true" || v === "yes" || v === "1") return 1;
  if (v === "off" || v === "false" || v === "no" || v === "0") return 0;
  // si viene "100.00" en válvulas, etc:
  const n = Number(v);
  if (!Number.isNaN(n)) return n;
  return null;
}

function parseHistoryText(text, isDriver=false) {
  const out = [];
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  for (const line of lines) {
    // separar por , ; o espacios múltiples
    let parts = line.split(",");
    if (parts.length < 2) parts = line.split(";");
    if (parts.length < 2) parts = line.split(/\s+/);

    if (parts.length < 2) continue;

    const ts = parts[0].trim();
    const raw = parts.slice(1).join(" ").trim();

    const t = new Date(ts);
    if (Number.isNaN(t.getTime())) continue;

    let v;
    if (isDriver) {
      v = normalizeOnOffTo01(raw);
      if (v === null) continue;
    } else {
      v = Number(String(raw).replace(",", "."));
      if (Number.isNaN(v)) continue;
    }
    out.push({ t, v });
  }

  // ordenar por tiempo
  out.sort((a,b) => a.t - b.t);
  return out;
}

async function fetchText(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  return await res.text();
}

async function fetchJSON(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  return await res.json();
}

function rangeToMs(r) {
  if (r === "24h") return 24 * 60 * 60 * 1000;
  if (r === "7d")  return 7  * 24 * 60 * 60 * 1000;
  if (r === "30d") return 30 * 24 * 60 * 60 * 1000;
  return null; // all
}

function filterByRange(series, rangeKey) {
  const ms = rangeToMs(rangeKey);
  if (!ms) return series;

  // usamos el último timestamp de la serie como "now" de referencia
  const last = series.length ? series[series.length - 1].t.getTime() : Date.now();
  const minT = last - ms;

  return series.filter(p => p.t.getTime() >= minT);
}

function buildCheckboxRow(container, item, label, checked, onChange) {
  const row = document.createElement("div");
  row.className = "row";

  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = checked;
  cb.addEventListener("change", () => onChange(cb.checked));

  const code = document.createElement("code");
  code.textContent = item;

  const span = document.createElement("span");
  span.textContent = label || "";

  row.appendChild(cb);
  row.appendChild(code);
  row.appendChild(span);

  container.appendChild(row);
}

function renderLists() {
  const sList = $("sList");
  const dList = $("dList");
  sList.innerHTML = "";
  dList.innerHTML = "";

  for (const s of state.sensors) {
    buildCheckboxRow(
      sList,
      s.item,
      `${s.label || ""}${s.units ? " ("+s.units+")" : ""}`,
      state.selectedS.has(s.item),
      (ok) => {
        if (ok) state.selectedS.add(s.item);
        else state.selectedS.delete(s.item);
        redraw();
      }
    );
  }

  for (const d of state.drivers) {
    buildCheckboxRow(
      dList,
      d.item,
      d.label || "",
      state.selectedD.has(d.item),
      (ok) => {
        if (ok) state.selectedD.add(d.item);
        else state.selectedD.delete(d.item);
        redraw();
      }
    );
  }
}

function fileForItem(item) {
  // Sensores: data/S1.txt
  if (/^S\d+$/.test(item)) return `${DATA_DIR}/${item}.txt`;
  // Drivers: data/d_D1.txt
  if (/^D\d+$/.test(item)) return `${DATA_DIR}/d_${item}.txt`;
  return null;
}

async function loadSeries(item) {
  if (state.cache.has(item)) return state.cache.get(item);

  const url = fileForItem(item);
  if (!url) return [];

  const isDriver = /^D\d+$/.test(item);
  const txt = await fetchText(url);
  const series = parseHistoryText(txt, isDriver);

  state.cache.set(item, series);
  return series;
}

function labelFor(item) {
  const s = state.sensors.find(x => x.item === item);
  if (s) return `${s.item} · ${s.label || ""}`.trim();
  const d = state.drivers.find(x => x.item === item);
  if (d) return `${d.item} · ${d.label || ""}`.trim();
  return item;
}

async function redraw() {
  const rangeKey = $("rangeSel").value;
  state.lastRange = rangeKey;

  const selS = Array.from(state.selectedS);
  const selD = Array.from(state.selectedD);

  setStatus(`Cargando series… (${selS.length} S + ${selD.length} D)`);

  // cargar en paralelo
  const allItems = [...selS, ...selD];
  const seriesArr = await Promise.all(allItems.map(it => loadSeries(it).catch(() => [])));

  // construir traces
  const traces = [];

  // Temperaturas superpuestas (MISMO eje y)
  for (let i = 0; i < selS.length; i++) {
    const item = selS[i];
    const raw = seriesArr[i] || [];
    const serie = filterByRange(raw, rangeKey);

    traces.push({
      type: "scatter",
      mode: "lines",
      name: labelFor(item),
      x: serie.map(p => p.t),
      y: serie.map(p => p.v),
      yaxis: "y",
      hovertemplate: "%{x}<br>%{y:.2f}°C<extra></extra>",
    });
  }

  // Drivers (0/1) en y2, como step
  const dStartIndex = selS.length;
  for (let j = 0; j < selD.length; j++) {
    const item = selD[j];
    const raw = seriesArr[dStartIndex + j] || [];
    const serie = filterByRange(raw, rangeKey);

    traces.push({
      type: "scatter",
      mode: "lines",
      name: labelFor(item) + " (0/1)",
      x: serie.map(p => p.t),
      y: serie.map(p => p.v),
      yaxis: "y2",
      line: { shape: "hv" },
      hovertemplate: "%{x}<br>%{y}<extra></extra>",
    });
  }

  // status timestamp (si hay series)
  let lastTs = null;
  for (const it of allItems) {
    const s = state.cache.get(it);
    if (s && s.length) {
      const t = s[s.length - 1].t.getTime();
      if (!lastTs || t > lastTs) lastTs = t;
    }
  }
  state.lastUpdated = lastTs ? new Date(lastTs) : null;

  const layout = {
    margin: { l: 60, r: 60, t: 30, b: 50 },
    legend: { orientation: "h" },
    xaxis: {
      title: "Fecha y hora",
      showgrid: true,
      zeroline: false,
    },
    yaxis: {
      title: "Temperatura (°C)",
      showgrid: true,
      zeroline: false,
      automargin: true,
    },
    yaxis2: {
      title: "Estado (0/1)",
      overlaying: "y",
      side: "right",
      range: [-0.1, 1.1],
      showgrid: false,
      zeroline: false,
      automargin: true,
    },
    hovermode: "x unified",
  };

  const config = {
    responsive: true,
    scrollZoom: true,
    displaylogo: false,
  };

  if (!traces.length) {
    setStatus("Selecciona alguna serie (S o D)");
    Plotly.newPlot("plot", [{
      type:"scatter", mode:"lines", x:[], y:[]
    }], layout, config);
    return;
  }

  Plotly.newPlot("plot", traces, layout, config);

  const stamp = state.lastUpdated ? state.lastUpdated.toISOString() : "—";
  setStatus(`Mostrando: ${selS.length} S + ${selD.length} D · ${stamp}`);
}

function resetZoom() {
  Plotly.relayout("plot", {
    "xaxis.autorange": true,
    "yaxis.autorange": true,
    "yaxis2.autorange": false,
  });
}

async function init() {
  try {
    setStatus("Cargando latest_all.json…");
    const meta = await fetchJSON(`${DATA_DIR}/latest_all.json`);
    state.meta = meta;

    // sensores y drivers desde latest_all.json
    state.sensors = (meta.sensors || [])
      .filter(x => /^S\d+$/.test(String(x.item||"").trim()))
      .map(x => ({ item: String(x.item).trim(), label: x.label || "", units: x.units || "" }))
      .sort((a,b) => Number(a.item.slice(1)) - Number(b.item.slice(1)));

    state.drivers = (meta.drivers || [])
      .filter(x => /^D\d+$/.test(String(x.item||"").trim()))
      .map(x => ({ item: String(x.item).trim(), label: x.label || "", units: x.units || "" }))
      .sort((a,b) => Number(a.item.slice(1)) - Number(b.item.slice(1)));

    // selección inicial: ninguna (o pon aquí defaults si quieres)
    state.selectedS = new Set();
    state.selectedD = new Set();

    renderLists();

    // pintar vacío al inicio
    await redraw();

  } catch (e) {
    console.error(e);
    setStatus("Error cargando datos (mira consola).");
  }
}

// botones
$("btnReload").addEventListener("click", async () => {
  // limpiamos cache para forzar refresco
  state.cache.clear();
  await init();
});

$("btnResetZoom").addEventListener("click", resetZoom);

$("rangeSel").addEventListener("change", () => redraw());

$("sAll").addEventListener("click", () => {
  state.sensors.forEach(s => state.selectedS.add(s.item));
  renderLists();
  redraw();
});
$("sNone").addEventListener("click", () => {
  state.selectedS.clear();
  renderLists();
  redraw();
});

$("dAll").addEventListener("click", () => {
  state.drivers.forEach(d => state.selectedD.add(d.item));
  renderLists();
  redraw();
});
$("dNone").addEventListener("click", () => {
  state.selectedD.clear();
  renderLists();
  redraw();
});

init();
</script>
</body>
</html>
